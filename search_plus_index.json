{"./":{"url":"./","title":"前言","keywords":"","body":"我描述 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:21 "},"source/Git/忽略已经被git管理的文件.html":{"url":"source/Git/忽略已经被git管理的文件.html","title":"忽略已经被git管理的文件","keywords":"","body":".gitignore规则和忽略已经被git管理的文件 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 惊叹号（!）取反。表示不忽略 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9]这里写代码片 表示匹配所有 0 到 9 的数字）。 使用两个星号（*) 表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。 我们再看一个 .gitignore 文件的例子： # no .a files *.a # but do track lib.a, even though you're ignoring .a files above !lib.a # only ignore the TODO file in the current directory, not subdir/TODO /TODO # ignore all files in the build/ directory build/ # ignore doc/notes.txt, but not doc/server/arch.txt doc/*.txt # ignore all .pdf files in the doc/ directory doc/**/*.pdf 如何忽略已经被git管理的文件 .gitignore 文件 一般再项目建立的时候就应该写好，这样才能有效，但如果是已经被git管理的文件，后边发现不想再跟踪了，直接再.gitignore添加此文件 是不会生效的 。有效的操作如下； #1.git rm -r --cached 此命令的含义是untrack 指定的fileA，或者使用 --cached . 表示将untrack 工作目录下的所有文件。 #2.修改.gitignore 文件 将fileA 添加到忽略文件中 #3.提交 最后一步就是将修改提交。 git add . git commit -m \"ignore fileA\" git push Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Git/全局设置用户名邮箱配置.html":{"url":"source/Git/全局设置用户名邮箱配置.html","title":"全局设置用户名邮箱配置","keywords":"","body":"[git命令：全局设置用户名邮箱配置] 1、查看git配置信息 git config --list 2、查看git用户名 git config user.name 3、查看邮箱配置 git config user.email 4、全局配置用户名 git config --global user.name \"nameVal\" 5、全局配置邮箱 git config --global user.email \"eamil@qq.com\" git生成并添加SSH key ① cd ~/.ssh/ 【如果没有对应的文件夹，则执行 mkdir ./.ssh】 ② git config --global user.name \"xb12369\" ③ git config --global user.email \"1234@qq.com\" ④ ssh-keygen -t rsa -C \"1234@qq.com\" 4、找到C:\\Users\\xb12369.ssh 目录，里面有两个文件：id_rsa和id_rsa.pub 5、配置ssh【这里是id_rsa.pub里面的内容啊】 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/IDEA/IDEA模板设置.html":{"url":"source/IDEA/IDEA模板设置.html","title":"IDEA模板设置","keywords":"","body":"IDEA类和方法注释模板设置 这里设置的注释模板采用Eclipse的格式，下面先贴出Eclipse的注释模板，我们就按照这种格式来设置： 类注释模板： /** * @author 4005517 * @ClassName xxxController * @Description TODO * @Date 2019/7/2 17:15 */ 方法注释模板： /** * @Author 4005517 * @Description //TODO * @Date 2019/7/2 17:21 * @Param [obj] * @return boolean */ 一、首先我们来设置IDEA中类的模板：（IDEA中在创建类时会自动给添加注释） 1、File-->settings-->Editor-->File and Code Templates-->Files 我们选择Class文件（当然你要设置接口的还也可以选择Interface文件） （1）${NAME}：设置类名，与下面的${NAME}一样才能获取到创建的类名 （2）TODO：代办事项的标记，一般生成类或方法都需要添加描述 （3）${USER}、${DATE}、${TIME}：设置创建类的用户、创建的日期和时间，这些事IDEA内置的方法，还有一些其他的方法在绿色框标注的位置，比如你想添加项目名则可以使用${PROJECT_NAME} （4）1.0：设置版本号，一般新创建的类都是1.0版本，这里写死就可以了 2、效果图展示 二、设置方法注释模板 IDEA还没有智能到自动为我们创建方法注释，这就是要我们手动为方法添加注释，使用Eclipse时我们生成注释的习惯是 /**+Enter，这里我们也按照这种习惯来设置IDEA的方法注释 1、File-->Settings-->Editor-->Live Templates (1）新建组：命名为userDefine （2）新建模板：命名为add 因为IDEA生成注释的默认方式是：/*+模板名+快捷键（比如若设置模板名为add快捷键用Tab，则生成方式为 /*add+Tab），如果不采用这样的生成方式IDEA中没有内容的方法将不可用，例如获取方法参数的methodParameters(）、 获取方法返回值的methodReturnType(） （3）设置生成注释的快捷键 （4）设置模板：模板内容如下 注意第一行，只有一个而不是/ 在设置参数名时必须用${参数名}$的方式，否则第五步中读取不到你设置的参数名 * * @Author 4005517 * @Description //TODO $end$ * @Date $date$ $time$ * @Param $param$ * @return $return$ */ 生成的模板注释将会是如下效果：所以我们要去掉最前面的/* （5）设置模板的应用场景 点击模板页面最下方的警告，来设置将模板应用于那些场景，一般选择EveryWhere-->Java即可 （如果曾经修改过，则显示为change而不是define） （6）设置参数的获取方式 选择右侧的Edit variables按钮 PS:第五步和第六步顺序不可颠倒，否则第六步将获取不到方法 选择每个参数对应的获取方法（在下拉选择框中选择即可），网上有很多教程说获取param时使用脚本的方式，我试过使用脚本的方式不仅麻烦而且只能在方法内部使用注释时才能获取到参数 （7）效果图 创建方法，在方法上面写：/*+模板名(add)+Enter /** * @Author 4005517 * @Description //TODO * @Date 2019/7/2 17:45 * @Param [loginName, passWord] * @return java.lang.String */ public String test(String loginName,String passWord){ return \"test hello\"; } Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Windows/Hyper-V使用.html":{"url":"source/Windows/Hyper-V使用.html","title":"Hyper-V使用","keywords":"","body":"Hyper-V使用 1.找Hyper-V功能 2.开启服务 点击确定按钮后，系统提示重启，重新启动系统 3.安装虚拟机 1.启动应用服务 重启系统后，在应用程序下查找Hyper-V服务 2.新建虚拟机 3.自定义名称及存放路径 4.选择代 请选择[第一代]，否则后面安装CentOS会出错 5.分配内存 根据自身机器情况分配内存 6.配置网络 先不配置，默认即可 6.虚拟硬盘配置 选择创建虚拟硬盘，点击下一步 7.安装选项配置 选择第二个，设置下载好的iso镜像 8.点击完成 9.启动虚拟机 4.安装CentOS系统 请参考另一篇文章虚拟机安装中的虚拟机安装设置部分 ... 等待安装完成 5.网络设置 1.首先创建个虚拟交换机 2.选择外部，点击创建 3.选择你要连接的网卡，一般选择能上网的真实网卡 4.点击设置 5.选择刚刚创建的网络虚拟交换机 6.重启下centos,然后编辑你的第一个网卡（一般情况） [root@localhost ~]# cd /etc/sysconfig/network-scripts/ [root@localhost network-scripts]# vi ifcfg-eth0 7.再配置里面这个改成yes 8.然后重启网络 [root@localhost network-scripts]# service network restart Restarting network (via systemctl): [ ok ] 9.查看下ip,已经自动分配ip了 10.测试一下访问百度也可以访问了 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/虚拟机安装.html":{"url":"source/Linux/虚拟机安装.html","title":"虚拟机安装","keywords":"","body":"VMware Workstation14安装CentOS7.0 详情教程 1.准备工作 a)下载VMware workstation14 vmware下载地址：传送门) b)下载CentOS7 下载地址：http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Everything-1804.iso c)下载SSH Secure Shell Client 2.虚拟机配置 a)打开虚拟机软件“VMware Workstation”，选择“创建新的虚拟机” b)选择“典型”选项，点击“下一步” c)选择“稍后安装操作系统”，点击“下一步” d)客户机操作选择“Linux”,版本选择“CentOS 7 64位”，点击“下一步” 　e)输入“虚拟机名称”；点击“浏览”按钮，选择虚拟机文件保存的位置；点击“下一步 f)默认设置，选择“下一步” g)自定义硬件配置 h)选择“新CD/DVD”, 选择“使用ISO镜像文件”，然后点击“浏览”，找到刚才下载的centOS7镜像文件，然后点击下面的确定 i)点击“完成” 3.安装centOs7 a)开启虚拟机 b)如果出现下图的错误，需要到BIOS中设置（百度搜索一大堆解决方案） c)选择语言“中文-简体中文” d)接下来显示“安装信息摘要”页面； 点击其中的每一项进行设置，也可以使用默认设置； 软件选择：决定了系统安装后包括哪些功能，如果使用默认值，那么系统安装后是没有图形界面的；选择“GNOME 桌面”，会显示图形界面；本着学习的目的，这里选择默认设置“最小安装”；如果怕麻烦，直接选择GNOME桌面 e)安装目标位置：自动配置分区 f)网络和主机名：打开连接开关，记住IP地址，SSH登录时使用，设置主机名，点击“应用”生效 g)开始安装 h)设置ROOT密码 i)等待安装 j)按照成功后，进行登录 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/zookeeper.html":{"url":"source/Linux/zookeeper.html","title":"zookeeper","keywords":"","body":"Zookeeper 安装 在安装ZooKeeper之前，请确保你的系统是在以下任一操作系统上运行： **任意Linux OS** - 支持开发和部署。适合演示应用程序。 **Windows OS** - 仅支持开发。 **Mac OS** - 仅支持开发。 ZooKeeper服务器是用Java创建的，它在JVM上运行。你需要使用JDK 6或更高版本。 现在，按照以下步骤在你的机器上安装ZooKeeper框架。 步骤1：验证Java安装 相信你已经在系统上安装了Java环境。现在只需使用以下命令验证它。 $ java -version 如果你在机器上安装了Java，那么可以看到已安装的Java的版本。否则，请按照以下简单步骤安装最新版本的Java。 步骤1.1：下载JDK 通过访问链接下载最新版本的JDK，并下载最新版本的Java。 最新版本（在编写本教程时）是JDK 8u 60，文件是“jdk-8u60-linuxx64.tar.gz\"。请在你的机器上下载该文件。 步骤1.2：提取文件 通常，文件会下载到download文件夹中。验证并使用以下命令提取tar设置。 $ cd /go/to/download/path $ tar -zxf jdk-8u60-linux-x64.gz 步骤1.3：移动到opt目录 要使Java对所有用户可用，请将提取的Java内容移动到“/usr/local/java\"文件夹。 $ su password: (type password of root user) $ mkdir /opt/jdk $ mv jdk-1.8.0_60 /opt/jdk/ 步骤1.4：设置路径 要设置路径和JAVA_HOME变量，请将以下命令添加到〜/.bashrc文件中。 export JAVA_HOME = /usr/jdk/jdk-1.8.0_60 export PATH=$PATH:$JAVA_HOME/bin 现在，将所有更改应用到当前运行的系统中。 $ source ~/.bashrc 步骤1.5：Java替代 使用以下命令更改Java替代项。 update-alternatives --install /usr/bin/java java /opt/jdk/jdk1.8.0_60/bin/java 100 步骤1.6 使用步骤1中说明的验证命令(java -version)验证Java安装。 步骤2：ZooKeeper框架安装 步骤2.1：下载ZooKeeper 要在你的计算机上安装ZooKeeper框架，请访问以下链接并下载最新版本的ZooKeeper。http://zookeeper.apache.org/releases.html 到目前为止，最新版本的ZooKeeper是3.4.6(ZooKeeper-3.4.6.tar.gz)。 步骤2.2：提取tar文件 使用以下命令提取tar文件 $ cd opt/ $ tar -zxf zookeeper-3.4.6.tar.gz $ cd zookeeper-3.4.6 $ mkdir data 步骤2.3：创建配置文件 使用命令 vi conf/zoo.cfg 和所有以下参数设置为起点，打开名为 conf/zoo.cfg 的配置文件。 $ vi conf/zoo.cfg tickTime = 2000 dataDir = /path/to/zookeeper/data clientPort = 2181 initLimit = 5 syncLimit = 2 一旦成功保存配置文件，再次返回终端。你现在可以启动zookeeper服务器。 步骤2.4：启动ZooKeeper服务器 执行以下命令 $ bin/zkServer.sh start 执行此命令后，你将收到以下响应 $ JMX enabled by default $ Using config: /Users/../zookeeper-3.4.6/bin/../conf/zoo.cfg $ Starting zookeeper ... STARTED 步骤2.5：启动CLI 键入以下命令 $ bin/zkCli.sh 键入上述命令后，将连接到ZooKeeper服务器，你应该得到以下响应。 Connecting to localhost:2181 ................ ................ ................ Welcome to ZooKeeper! ................ ................ WATCHER:: WatchedEvent state:SyncConnected type: None path:null [zk: localhost:2181(CONNECTED) 0] 停止ZooKeeper服务器 连接服务器并执行所有操作后，可以使用以下命令停止zookeeper服务器。 $ bin/zkServer.sh stop 客户端连接报错如下： Opening socket connection to server localhost.dolojia/192.168.112.131:2181. Will not attempt to authenticate using SASL (unknown error) 是因为防火墙的原因 在CentOS 7或RHEL 7中防火墙由firewalld来管理 firewall-cmd --zone=public --add-port=8088/tcp --permanent #（--permanent永久生效，没有此参数重启后失效） firewall-cmd --zone=public --remove-port=80/tcp --permanent #删除 systemctl start firewalld.service #查看防火墙状态 systemctl stop firewalld.service #完全关闭防火墙 firewall-cmd --permanent --zone=public --add-port=2181/tcp #打开2181端口 `` Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/Linux安装redis.html":{"url":"source/Linux/Linux安装redis.html","title":"Linux安装redis","keywords":"","body":"Linux下安装redis 一下载 下载地址：http://redis.io/download，下载最新稳定版本。 $ wget http://download.redis.io/releases/redis-5.0.5.tar.gz $ tar xzf redis-5.0.5.tar.gz $ cd redis-5.0.5 $ make 二运行 $ cd src/ $ src/redis-server 三验证 [root@iz2ze0zcgmybh1wlebrk0mz src]# cd /usr/local/redis-5.0.5/src/ [root@iz2ze0zcgmybh1wlebrk0mz src]# ./redis-cli 127.0.0.1:6379> set test 20 OK Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/Linux安装Elasticsearch.html":{"url":"source/Linux/Linux安装Elasticsearch.html","title":"Linux安装Elasticsearch","keywords":"","body":"Linux安装Elasticsearch 　下载安装包 官网下载地址https://www.elastic.co/cn/downloads/elasticsearch 解压安装包 tar -zxvf elasticsearch-7.3.1-linux-x86_64.tar.gz 修改 config 目录下的 elasticsearch.yml 文件 // 去掉行开头的 # 并重命名集群名，这里命名为 compass cluster.name: compass // 去掉行开头的 # 并重命名节点名，这里命名为 node-1 node.name: node-1 启动ES： 版本> = 5.0.0 时，是不能用超级管理员运行的，此时需要切换到普通账号或者新建 ES 账号 [root@localhost elasticsearch-7.3.1]# sh bin/elasticsearch OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release. [2019-08-29T10:11:09,644][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [localhost.dolojia] uncaught exception in thread [main] org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:163) ~[elasticsearch-7.3.1.jar:7.3.1] at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:150) ~[elasticsearch-7.3.1.jar:7.3.1] at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-7.3.1.jar:7.3.1] at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-7.3.1.jar:7.3.1] at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-7.3.1.jar:7.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:115) ~[elasticsearch-7.3.1.jar:7.3.1] at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:92) ~[elasticsearch-7.3.1.jar:7.3.1] Caused by: java.lang.RuntimeException: can not run elasticsearch as root at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:105) ~[elasticsearch-7.3.1.jar:7.3.1] at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:172) ~[elasticsearch-7.3.1.jar:7.3.1] at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:349) ~[elasticsearch-7.3.1.jar:7.3.1] at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:159) ~[elasticsearch-7.3.1.jar:7.3.1] ... 6 more 创建es专属用户启动 ① 新建用户组 elasticsearch $ groupadd elasticsearch ② 新建用户并指定用户组 $ useradd -g elasticsearch elasticsearch ③ 修改 ES 目录所属者 $ chown -R elasticsearch:elasticsearch elasticsearch ④ 切换用户后再次启动 $ su elasticsearch 只能使用127.0.01或者localhost访问，使用ip地址无法访问 #修改 elasticsearch.yml 中的「network.host」 network.host: 0.0.0.0 验证是否启动成功 [root@localhost opt]# curl http://localhost:9200 { \"name\" : \"localhost.dolojia\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"wJIrmAaDRu--MfaRHtr70w\", \"version\" : { \"number\" : \"7.3.1\", \"build_flavor\" : \"default\", \"build_type\" : \"tar\", \"build_hash\" : \"4749ba6\", \"build_date\" : \"2019-08-19T20:19:25.651794Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.1.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/Linux下java环境搭建.html":{"url":"source/Linux/Linux下java环境搭建.html","title":"Linux下java环境搭建","keywords":"","body":"Linux下java环境搭建 rpm方式安装JDK 1.下载JDK 下载地址 在usr/local下新建目录Java [root@iz2ze0zcgmybh1wlebrk0mz local]# mkdir java 将下载好的jdk-7u71-linux-x64.rpm文件拷贝到 Java目录中 上传完后的文件如下，文件只有读写权限，没有执行权限 使用如下命令授权，如果文件已经有了执行权限，此步骤可省略 # chmod 755 jdk-7u71-linux-x64.rpm 2.安装JDK 执行如下命令安装jdk # rpm -ivh jdk-7u71-linux-x64.rpm 如果在安装时出现如下错误 warning:waiting for transaction lock on /var/lib/rpm/.rpm.lock 使用如下命令来进行安装 # sudo rpm -ivh jdk-7u71-linux-x64.rpm 如果仍然不可以，使用如下命令强制解锁后再次安装即可 # sudo rm /var/lib/rpm/.rpm.lock 3.配置环境变量 使用 vim 编辑器打开文件/etc/profile # vim /etc/profile 在文件尾部添加如下内容，保存退出 export JAVA_HOME=/usr/java/jdk1.7.0_71 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool.jar 此时，我们刚刚配置的环境变量并没有起效，输入如下命令，使用环境变量立即生效 # source /etc/profile 输入如下命令验证环境变量是否生效 # echo $PATH 输入如下命令查看jdk版本 # java -version openjdk version \"1.8.0_181\" OpenJDK Runtime Environment (build 1.8.0_181-b13) OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode) yum安装JDK 1.检查系统原版并卸载 输入如下命令查看系统已安装的jdk # rpm -qa | grep java # rpm -qa | grep jdk 如果已经安装了jdk，使用如下命令卸载，yum会自动检测，卸载删除jdk的相关安装包 # yum -y remove java* # yum -y remove jdk* 2.jdk安装 查看java相关列表（jdk版本信息），笔者选择安装的是openjdk1.8 # yum list | grep jdk 3.使用如下命令安装jdk # yum -y install java-1.8.0-openjdk.x86_64 4. 等待安装完成，验证版本 # java -version openjdk version \"1.8.0_181\" OpenJDK Runtime Environment (build 1.8.0_181-b13) OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode) Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/mongodb安装.html":{"url":"source/Linux/mongodb安装.html","title":"mongodb安装","keywords":"","body":"安装MongoDB Configure the package management system (yum) Create a /etc/yum.repos.d/mongodb-org-4.0.repo file so that you can install MongoDB directly using yum: [mongodb-org-4.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc Install the MongoDB packages. 安装MongoDB的最新的稳定版本,发出以下命令 sudo yum install -y mongodb-org 安装MongoDB的特定版本,指定每个组件分别包和包名称添加版本号,如以下示例 sudo yum install -y mongodb-org-4.0.2 mongodb-org-server-4.0.2 mongodb-org-shell-4.0.2 mongodb-org-mongos-4.0.2 mongodb-org-tools-4.0.2 出现错误：curl: (35) SSL connect error 原因：nss版本太旧，升级解决 [root@IDCWX16 mongodb]# yum -y update nss Run MongoDB Community Edition（运行MongoDB社区版 ） Start MongoDB： sudo service mongod start Stop MongoDB： sudo service mongod stop Restart MongoDB sudo service mongod restart Begin using MongoDB mongo --host 127.0.0.1:27017 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/mysql安装.html":{"url":"source/Linux/mysql安装.html","title":"mysql安装","keywords":"","body":"mysql安装 cd /usr/local/ wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz ll -t 查看已经下载好了安装包mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 解压 tar -zxvf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 复制 cp -r mysql-5.7.22-linux-glibc2.12-x86_64 /usr/local/mysql 2、添加系统mysql组和mysql用户 添加系统mysql组 groupadd mysql 添加mysql用户 useradd -r -g** mysql mysql **（添加完成后可用id mysql查看） 安装数据库 修改当前目录拥有者为mysql用户 chown -R mysql:mysql ./ bin/mysqld --initialize --user=root --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data 如果出现错误: ./bin/mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory 请执行 yum install -y libaio 后再执行上面命令 成功后输出如下内容,生成了临时密码(Zy=lxsEkr0gM) ```2018-08-27T12:05:38.545487Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details). 2018-08-27T12:05:38.545487Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details). 2018-08-27T12:05:39.600635Z 0 [Warning] InnoDB: New log files created, LSN=45790 2018-08-27T12:05:39.722897Z 0 [Warning] InnoDB: Creating foreign key constraint system tables. 2018-08-27T12:05:39.786218Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 83c6e27b-a9f1-11e8-873a-00163e0caf40. 2018-08-27T12:05:39.788230Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened. 2018-08-27T12:05:39.788701Z 1 [Note] A temporary password is generated for root@localhost: Zy=lxsEkr0gM 配置my.cnf **vim /etc/my.cnf ** 写入如下内容 ``` [mysqld] character_set_server=utf8 init_connect='SET NAMES utf8' basedir=/usr/local/mysql datadir=/usr/local/mysql/data socket=/tmp/mysql.sock 不区分大小写 (sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 这个简单来说就是sql语句是否严格) lower_case_table_names = 1 log-error=/var/log/mysqld.log #chown -R mysql:mysql /var/log/ 需要给他赋mysql权限 pid-file=/usr/local/mysql/data/mysqld.pid 添加开机启动 `cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld ` 修改 vim /etc/init.d/mysqld ``` shell vim /etc/init.d/mysqld basedir=/usr/local/mysql datadir=/usr/local/mysql/data ``` 启动mysql ``` shell service mysql start ``` 登录修改密码 mysql -uroot -p 上面初始化时的密码 **如果出现错误 需要添加软连接 ln -s /usr/local/mysql/bin/mysql /usr/bin** ```shell alter user 'root'@'localhost' identified by 'root'; flush privileges; #刷新权限 GRANT ALL PRIVILEGES ON *.* TO 'root1'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION; #授权新用户root1 ``` 使用客户端连接mysql,出现如下错误, 远程权限问题。 出现“服务器连接错误Host 'XXX' is not allowed to connect to this MySQL server”的错误,看上面设置权限 ```` Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/安装RabbitMQ.html":{"url":"source/Linux/安装RabbitMQ.html","title":"安装RabbitMQ","keywords":"","body":"安装RabbitMQ 安装erlang（通过yum源来安装） 因为RabbitMQ是由erlang实现的，所以要先安装erlang再安装rabbitMQ 下载命令： [root@iz2ze0zcgmybh1wlebrk0mz local]# wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm 加入yum源： [root@iz2ze0zcgmybh1wlebrk0mz local]# rpm -Uvh erlang-solutions-1.0-1.noarch.rpm 开始安装： [root@iz2ze0zcgmybh1wlebrk0mz local]# yum install erlang 安装rabbitmq 下载地址命令： [root@iz2ze0zcgmybh1wlebrk0mz local]# wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el6.noarch.rpm 安装命令： [root@iz2ze0zcgmybh1wlebrk0mz local]# yum install rabbitmq-server-3.6.15-1.el6.rpm 配置rabbitmq 先查看服务状态 [root@iz2ze0zcgmybh1wlebrk0mz ebin]# systemctl status rabbitmq-server.service ● rabbitmq-server.service - LSB: Enable AMQP service provided by RabbitMQ broker Loaded: loaded (/etc/rc.d/init.d/rabbitmq-server; bad; vendor preset: disabled) Active: active (running) since Tue 2018-08-28 17:46:50 CST; 48min ago Docs: man:systemd-sysv-generator(8) Process: 4672 ExecStop=/etc/rc.d/init.d/rabbitmq-server stop (code=exited, status=0/SUCCESS) Process: 5036 ExecStart=/etc/rc.d/init.d/rabbitmq-server start (code=exited, status=0/SUCCESS) CGroup: /system.slice/rabbitmq-server.service ├─5252 /bin/sh /etc/rc.d/init.d/rabbitmq-server start ├─5259 /bin/bash -c ulimit -S -c 0 >/dev/null 2>&1 ; /usr/sbin/rabbitmq-server └─5261 /bin/sh /usr/sbin/rabbitmq-server Aug 28 17:46:46 iz2ze0zcgmybh1wlebrk0mz systemd[1]: Starting LSB: Enable AMQP service provided by RabbitMQ broker... Aug 28 17:46:46 iz2ze0zcgmybh1wlebrk0mz su[5128]: (to rabbitmq) root on none Aug 28 17:46:46 iz2ze0zcgmybh1wlebrk0mz su[5278]: (to rabbitmq) root on none Aug 28 17:46:46 iz2ze0zcgmybh1wlebrk0mz su[5279]: (to rabbitmq) root on none Aug 28 17:46:50 iz2ze0zcgmybh1wlebrk0mz rabbitmq-server[5036]: Starting rabbitmq-server: SUCCESS Aug 28 17:46:50 iz2ze0zcgmybh1wlebrk0mz rabbitmq-server[5036]: rabbitmq-server. Aug 28 17:46:50 iz2ze0zcgmybh1wlebrk0mz systemd[1]: Started LSB: Enable AMQP service provided by RabbitMQ broker. 启动服务 [root@iz2ze0zcgmybh1wlebrk0mz local]# service rabbitmq-server start Starting rabbitmq-server (via systemctl): [ OK ] 或者 [root@iz2ze0zcgmybh1wlebrk0mz local]# /sbin/service rabbitmq-server start 配置可视化管理界面 安装插件 [root@iz2ze0zcgmybh1wlebrk0mz local]# /sbin/rabbitmq-plugins enable rabbitmq_management 重启服务 [root@iz2ze0zcgmybh1wlebrk0mz local]# service rabbitmq-server restart 通过http://ip:15672 使用默认账号密码guest,guest登陆web页面 登录出现错误User can only log in via localhost 原因 rabbitmq从3.3.0开始禁止使用guest/guest权限通过除localhost外的访问 解决方案 1. 找到/rabbitmq_server-3.6.14/ebin下面的rabbit.app文件 2. 将loopback_users里的>删除 结果：[{rabbit, [{loopback_users, []}]}]. 3. 重启服务 systemctl restart rabbitmq-server.service 用户管理 查看当前用户 [root@iz2ze0zcgmybh1wlebrk0mz ebin]# rabbitmqctl list_users Listing users admin [administrator] guest [administrator] 创建用户： [root@iz2ze0zcgmybh1wlebrk0mz local]# rabbitmqctl add_user admin 123456 赋予管理员权限 [root@iz2ze0zcgmybh1wlebrk0mz local]# rabbitmqctl set_user_tags admin administrator 或者直接在web管理界面创建用户并赋权限 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Linux/contos7防火墙关闭.html":{"url":"source/Linux/contos7防火墙关闭.html","title":"contos7防火墙关闭","keywords":"","body":"contos7防火墙关闭 查看防火前状态 [es@localhost bin]$ systemctl status firewalld.service ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled) Active: active (running) since 二 2019-09-03 14:25:37 CST; 20min ago Docs: man:firewalld(1) Main PID: 6585 (firewalld) CGroup: /system.slice/firewalld.service └─6585 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid 关闭防火墙需输入root密码确认权限 [es@localhost bin]$ systemctl stop firewalld.service ==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units === Authentication is required to manage system services or units. Authenticating as: root Password: ==== AUTHENTICATION COMPLETE === 再次查看状态：Active: active (running)变为Active: inactive (dead)说明关闭成功 永久关闭防火墙 [es@localhost bin]$ systemctl disable firewalld.service ==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-unit-files === Authentication is required to manage system service or unit files. Authenticating as: root Password: ==== AUTHENTICATION COMPLETE === Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Docker/CentOS 7安装Docker.html":{"url":"source/Docker/CentOS 7安装Docker.html","title":"CentOS 7安装Docker","keywords":"","body":"CentOS 7安装Docker Docker支持以下的CentOS版本： CentOS 7 (64-bit) CentOS 6.5 (64-bit) 或更高的版本 查看系统版本 [root@localhost ~]# uname -r 3.10.0-957.el7.x86_64 Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。 使用 yum 安装（CentOS 7下） 安装 Docker 从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。 Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用 本文使用 Docker CE 的安装 1.移除旧的版本： $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 2.安装一些必要的系统工具： [root@localhost ~]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2 3.添加软件源信息 [root@localhost ~]# sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 4.更新 yum 缓存 [root@localhost ~]# sudo yum makecache fast 5.安装 Docker-ce [root@localhost ~]# sudo yum -y install docker-ce 6.启动 Docker 后台服务 [root@localhost ~]# sudo systemctl start docker 7.测试运行 hello-world [root@localhost ~]# docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 1b930d010525: Pull complete Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。 到此，Docker 在 CentOS 系统的安装完成。 镜像加速 鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。 新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\\docker\\config\\daemon.json（Windows） 来配置 Daemon。 请在该配置文件中加入（没有该文件的话，请先建一个）： { \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"] } 删除 Docker CE $ sudo yum remove docker-ce $ sudo rm -rf /var/lib/docker Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Docker/Docker常用命令介绍.html":{"url":"source/Docker/Docker常用命令介绍.html","title":"Docker常用命令介绍","keywords":"","body":"Docker常用命令介绍 一、帮助命令 docker version docker info docker --help docker run --help 查看run命令示例 二、镜像命令 docker images 查看镜像 -a 列出所有镜像 -q 只显示镜像id --digests 显示摘要信息 --no-trunc docker search 搜索镜像 #docker search 镜像名 [root@localhost docker]# docker search tomcat docker pull 下载镜像 #docker pull 镜像名 [root@localhost docker]# docker pull tomcat docker rmi 删除镜像 删除单个docker rmi -f 镜像名 删除多个docker rmi -f 镜像名1:tag1 镜像名2:tag2 删除全部docker rmi -f ${docker images -q} docker commit将现有容器制作为镜像 #docker commit -m=\"描述信息\" -a=\"作者\" 容器id 目标镜像名:[标签] [root@localhost docker]# docker commit -m=\"描述信息\" -a=\"作者\" b4vfd526 tocmat-test2:2.0 三、容器命令 docker run 新建并启动容器 #docker run [OPTIONS] IMAGE [COMMAND] [ARG...] [root@localhost docker]# docker run -d -p 8080:8080 --name tomcat_server tomcat -- name 为容器取一个新名字 -d 后台运行 -i 交互方式运行 -t 启动一个伪终端 -p 指定端口映射 -q 随机端口映射 --env 配置环境变量 [root@localhost docker]# docker run --env config_env=dev -d -p 8080:8080 --name tomcat_server tomcat docker ps 查看容器 [root@localhost docker]# docker ps -a -a 列出所有容器 -l 列出最近创建的容器 -n 显示最近穿件的N个容器 -q 只显示容器id 退出容器 exit 退出并停止容器 ctrl+p+q 退出不停止容器 docker start启动容器 docker start 容器id/名称 docker restart重启容器 docker restart 容器id/名称 docker stop停止容器 docker stop 容器id/名称 docker kill强制停止容器 docker kill 容器id/名称 docker -rm删除容器 docker -rm 容器id docker rm $(docker ps -aq)删除没在运行的容器 docker logs 查看容器日志 #docker logs [OPTIONS] CONTAINER [root@localhost docker]# docker logs -t -f --tail=10 6d1fd54ca10ad8f9e99 也可以在主机目录/var/lib/docker/containers/下找到对应容器日志 docker top 查看容器内进程 [root@localhost docker]# docker top 6d1fd54ca10ad8f9e docker inspect 查看容器详细信息 [root@localhost docker]# docker inspect 6d1fd54ca10ad8 docker exec 进入正在运行的容器 #docker exec [OPTIONS] CONTAINER COMMAND [ARG...] [root@localhost docker]# docker exec -it 6d1fd54ca10ad8f9 /bin/bash root@6d1fd54ca10a:/usr/local/tomcat# docker cp 从容器内部拷贝文件至主机 #docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- #docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH [root@localhost docker]# docker cp 6244e9d112a0:BUILDING.txt /home/ Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Docker/Dockerfile.html":{"url":"source/Docker/Dockerfile.html","title":"Dockerfile","keywords":"","body":"Dockerfile Dockerfile 是一个包含创建镜像所有命令的文本文件，通过docker build命令可以根据 Dockerfile 的内容构建镜像 基本语法结构 Dockerfile 有以下指令选项: FROM MAINTAINER RUN CMD EXPOSE ENV ADD COPY ENTRYPOINT VOLUME USER WORKDIR ONBUILD FROM FROM FROM指定构建镜像的基础源镜像，如果本地没有指定的镜像，则会自动从 Docker 的公共库 pull 镜像下来。 FROM必须是 Dockerfile 中非注释行的第一个指令，即一个 Dockerfile 从FROM语句开始。 FROM可以在一个 Dockerfile 中出现多次，如果有需求在一个 Dockerfile 中创建多个镜像。 如果FROM语句没有指定镜像标签，则默认使用latest标签。 MAINTAINER MAINTAINER 指定创建镜像的用户 RUN 有两种使用方式 RUN RUN \"executable\", \"param1\", \"param2\" 每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像，后续的RUN都在之前RUN提交后的镜像为基础，镜像是分层的，可以通过一个镜像的任何一个历史提交点来创建，类似源码的 版本控制 。 exec 方式会被解析为一个 JSON 数组，所以必须使用双引号而不是单引号。exec 方式不会调用一个命令 shell，所以也就不会继承相应的变量，如： RUN [ \"echo\", \"$HOME\" ] 这种方式是不会达到输出 HOME 变量的，正确的方式应该是这样的 RUN [ \"sh\", \"-c\", \"echo\", \"$HOME\" ] RUN产生的缓存在下一次构建的时候是不会失效的，会被重用，可以使用--no-cache选项，即docker build --no-cache，如此便不会缓存。 CMD CMD有三种使用方式: CMD \"executable\",\"param1\",\"param2\" CMD \"param1\",\"param2\" CMD command param1 param2 (shell form) CMD指定在 Dockerfile 中只能使用一次，如果有多个，则只有最后一个会生效。 CMD的目的是为了在启动容器时提供一个默认的命令执行选项。如果用户启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。 CMD会在启动容器的时候执行，build 时不执行，而RUN只是在构建镜像的时候执行，后续镜像构建完成之后，启动容器就与RUN无关了，这个初学者容易弄混这个概念，这里简单注解一下。 EXPOSE EXPOSE [...] 告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效。 ENV ENV # 只能设置一个变量 ENV = ... # 允许一次设置多个变量 指定一个环节变量，会被后续RUN指令使用，并在容器运行时保留。 例子: ENV myName=\"John Doe\" myDog=Rex\\ The\\ Dog \\ myCat=fluffy 等同于 ENV myName John Doe ENV myDog Rex The Dog ENV myCat fluffy ADD ADD ... ADD复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 。 支持通过 Go 的正则模糊匹配，具体规则可参见 Go filepath.Match ADD hom* /mydir/ # adds all files starting with \"hom\" ADD hom?.txt /mydir/ # ? is replaced with any single character 路径必须是绝对路径，如果 不存在，会自动创建对应目录 路径必须是 Dockerfile 所在路径的相对路径 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制 COPY COPY ... COPY复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS。 ENTRYPOINT ENTRYPOINT \"executable\", \"param1\", \"param2\" ENTRYPOINT command param1 param2 (shell form) 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。如果需要覆盖，则可以使用docker run --entrypoint选项。 每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个生效。 Exec form ENTRYPOINT 例子 通过ENTRYPOINT使用 exec form 方式设置稳定的默认命令和选项，而使用CMD添加默认之外经常被改动的选项。 FROM ubuntu ENTRYPOINT [\"top\", \"-b\"] CMD [\"-c\"] 通过 Dockerfile 使用ENTRYPOINT展示前台运行 Apache 服务 FROM debian:stable RUN apt-get update && apt-get install -y --force-yes apache2 EXPOSE 80 443 VOLUME [\"/var/www\", \"/var/log/apache2\", \"/etc/apache2\"] ENTRYPOINT [\"/usr/sbin/apache2ctl\", \"-D\", \"FOREGROUND\"] Shell form ENTRYPOINT 例子 这种方式会在/bin/sh -c中执行，会忽略任何CMD或者docker run命令行选项，为了确保docker stop能够停止长时间运行ENTRYPOINT的容器，确保执行的时候使用exec选项。 FROM ubuntu ENTRYPOINT exec top -b 如果在ENTRYPOINT忘记使用exec选项，则可以使用CMD补上: FROM ubuntu ENTRYPOINT top -b CMD --ignored-param1 # --ignored-param2 ... --ignored-param3 ... 依此类推 VOLUME VOLUME [\"/data\"] 创建一个可以从本地主机或其他容器挂载的挂载点，后续具体介绍。 USER USER daemon 指定运行容器时的用户名或 UID，后续的RUN、CMD、ENTRYPOINT也会使用指定用户。 WORKDIR WORKDIR /path/to/workdir 为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。 WORKDIR /a WORKDIR b WORKDIR c RUN pwd 最终路径是/a/b/c。 WORKDIR指令可以在ENV设置变量之后调用环境变量: ENV DIRPATH /path WORKDIR $DIRPATH/$DIRNAME 最终路径则为 /path/$DIRNAME。 ONBUILD ONBUILD [INSTRUCTION] 配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。 例如，Dockerfile 使用如下的内容创建了镜像 image-A： [...] ONBUILD ADD . /app/src ONBUILD RUN /usr/local/bin/python-build --dir /app/src [...] 如果基于 image-A 创建新的镜像时，新的 Dockerfile 中使用 FROM image-A 指定基础镜像时，会自动执行 ONBUILD 指令内容，等价于在后面添加了两条指令。 # Automatically run the following ADD . /app/src RUN /usr/local/bin/python-build --dir /app/src 使用ONBUILD指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild。 Dockerfile Examples # Nginx # # VERSION 0.0.1 FROM ubuntu MAINTAINER Victor Vieux RUN apt-get update && apt-get install -y inotify-tools nginx apache2 openssh-server # Firefox over VNC # # VERSION 0.3 FROM ubuntu # Install vnc, xvfb in order to create a 'fake' display and firefox RUN apt-get update && apt-get install -y x11vnc xvfb firefox RUN mkdir ~/.vnc # Setup a password RUN x11vnc -storepasswd 1234 ~/.vnc/passwd # Autostart firefox (might not be the best way, but it does the trick) RUN bash -c 'echo \"firefox\" >> /.bashrc' EXPOSE 5900 CMD [\"x11vnc\", \"-forever\", \"-usepw\", \"-create\"] # Multiple images example # # VERSION 0.1 FROM ubuntu RUN echo foo > bar # Will output something like ===> 907ad6c2736f FROM ubuntu RUN echo moo > oink # Will output something like ===> 695d7793cbe4 # You᾿ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with # /oink. docker build $ docker build --help Usage: docker build [OPTIONS] PATH | URL | - Build a new image from the source code at PATH --force-rm=false Always remove intermediate containers, even after unsuccessful builds # 移除过渡容器，即使构建失败 --no-cache=false Do not use cache when building the image # 不实用 cache -q, --quiet=false Suppress the verbose output generated by the containers --rm=true Remove intermediate containers after a successful build # 构建成功后移除过渡层容器 -t, --tag=\"\" Repository name (and optionally a tag) to be applied to the resulting image in case of success 参考文档: Dockerfile Reference dockerfile 最佳实践 使用.dockerignore文件 为了在docker build过程中更快上传和更加高效，应该使用一个.dockerignore文件用来排除构建镜像时不需要的文件或目录。例如,除非. Git 在构建过程中需要用到，否则你应该将它添加到.dockerignore文件中，这样可以节省很多时间。 避免安装不必要的软件包 为了降低复杂性、依赖性、文件大小以及构建时间，应该避免安装额外的或不必要的包。例如，不需要在一个 数据库 镜像中安装一个文本编辑器。 每个容器都跑一个进程 在大多数情况下，一个容器应该只单独跑一个程序。解耦应用到多个容器使其更容易横向扩展和重用。如果一个服务依赖另外一个服务，可以参考 Linking Containers Together 。 最小化层 我们知道每执行一个指令，都会有一次镜像的提交，镜像是分层的结构，对于Dockerfile，应该找到可读性和最小化层之间的平衡。 多行参数排序 如果可能，通过字母顺序来排序，这样可以避免安装包的重复并且更容易更新列表，另外可读性也会更强，添加一个空行使用\\换行: RUN apt-get update && apt-get install -y \\ bzr \\ cvs \\ git \\ mercurial \\ subversion 创建缓存 镜像构建过程中会按照Dockerfile的顺序依次执行，每执行一次指令 Docker 会寻找是否有存在的镜像缓存可复用，如果没有则创建新的镜像。如果不想使用缓存，则可以在docker build时添加--no-cache=true选项。 从基础镜像开始就已经在缓存中了，下一个指令会对比所有的子镜像寻找是否执行相同的指令，如果没有则缓存失效。在大多数情况下只对比Dockerfile指令和子镜像就足够了。ADD和COPY指令除外，执行ADD和COPY时存放到镜像的文件也是需要检查的，完成一个文件的校验之后再利用这个校验在缓存中查找，如果检测的文件改变则缓存失效。RUN apt-get -y update命令只检查命令是否匹配，如果匹配就不会再执行更新了。 为了有效地利用缓存，你需要保持你的 Dockerfile 一致，并且尽量在末尾修改。 Dockerfile 指令 FROM: 只要可能就使用官方镜像库作为基础镜像 RUN: 为保持可读性、方便理解、可维护性，把长或者复杂的RUN语句使用\\分隔符分成多行 不建议RUN apt-get update独立成行，否则如果后续包有更新，那么也不会再执行更新 避免使用RUN apt-get upgrade或者dist-upgrade，很多必要的包在一个非privileged权限的容器里是无法升级的。如果知道某个包更新，使用apt-get install -y xxx 标准写法 RUN apt-get update && apt-get install -y package-bar package-foo 例子: RUN apt-get update && apt-get install -y \\ aufs-tools \\ automake \\ btrfs-tools \\ build-essential \\ curl \\ dpkg-sig \\ git \\ iptables \\ libapparmor-dev \\ libcap-dev \\ libsqlite3-dev \\ lxc=1.0* \\ mercurial \\ parallel \\ reprepro \\ ruby1.9.1 \\ ruby1.9.1-dev \\ s3cmd=1.1.0* CMD: 推荐使用CMD [“executable”, “param1”, “param2”…]这种格式，CMD [“param”, “param”]则配合ENTRYPOINT使用 EXPOSE: Dockerfile 指定要公开的端口，使用docker run时指定映射到宿主机的端口即可 ENV: 为了使新的软件更容易运行，可以使用ENV更新PATH变量。如ENV PATH /usr/local/nginx/bin:$PATH确保CMD [\"nginx\"]即可运行 ENV也可以这样定义变量： ENV PG_MAJOR 9.3 ENV PG_VERSION 9.3.4 RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && … ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH ADDorCOPY:ADD比COPY多一些特性「tar 文件自动解包和支持远程 URL」，不推荐添加远程 URL 如不推荐这种方式: ADD http://example.com/big.tar.xz /usr/src/things/ RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things RUN make -C /usr/src/things all 推荐使用 curl 或者 wget 替换，使用如下方式: RUN mkdir -p /usr/src/things \\ && curl -SL http://example.com/big.tar.gz \\ | tar -xJC /usr/src/things \\ && make -C /usr/src/things all 如果不需要添加 tar 文件，推荐使用COPY。 原文地址：http://www.docker.org.cn/dockerppt/114.html Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Nginx/openReaty安装.html":{"url":"source/Nginx/openReaty安装.html","title":"openReaty安装","keywords":"","body":"openReaty安装 使用yum安装以下的开发库: yum install pcre-devel openssl-devel gcc curl ​ 在你的 CentOS 系统中添加 openresty 仓库，便于未来安装或更新，（通过 yum update 命令） sudo yum install yum-utils sudo yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo ​ 然后就可以像下面这样安装软件包，比如 openresty： sudo yum install openresty 启动nginx 验证是否成功 curl http://localhost:80/ ​ ​ grant all PRIVILEGES on db_name.* to 'mysql'@'%' identified by 'mysql123' WITH GRANT OPTION; Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Tomcat/tomcat配置详解.html":{"url":"source/Tomcat/tomcat配置详解.html","title":"tomcat配置详解","keywords":"","body":"tomcat中server.xml配置详解 元素结构 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ 元素节点介绍 元素名 属性 解释 server port 指定一个端口，这个端口负责监听关闭tomcat的请求 shutdown 指定向端口发送的命令字符串 service name 指定service的名字 Connector(表示客户端和service之间的连接) port 指定服务器端要创建的端口号，并在这个断口监听来自客户端的请求 minProcessors 服务器启动时创建的处理请求的线程数 maxProcessors 最大可以创建的处理请求的线程数 minSpareThreads 该Connector先创建5个线程等待客户请求，每个请求由一个线程负责 maxSpareThread 设定在监听端口的线程的最大数目,这个值也决定了服务器可以同时响应客户请求的最大数目.默认值为200 enableLookups 如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址 redirectPort 指定服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号 acceptCount 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理 connectionTimeout 指定超时的时间数(以毫秒为单位) Engine(表示指定service中的请求处理机，接收和处理来自Connector的请求) defaultHost 指定缺省的处理请求的主机名，它至少与其中的一个host元素的name属性值是一样的 Context(表示一个web应用程序，通常为WAR文件，关于WAR的具体信息见servlet规范) docBase 应用程序的路径或者是WAR文件存放的路径 path 表示此web应用程序的url的前缀，这样请求的url为http://localhost:8080/path/**** reloadable 这个属性非常重要，如果为true，则tomcat会自动检测应用程序的/WEB-INF/lib 和/WEB-INF/classes目录的变化，自动装载新的应用程序，我们可以在不重起tomcat的情况下改变应用程序 host(表示一个虚拟主机) name 指定主机名 appBase 应用程序基本目录，即存放应用程序的目录 unpackWARs 如果为true，则tomcat会自动将WAR文件解压，否则不解压，直接从WAR文件中运行应用程序 Logger(表示日志，调试和错误信息) className 指定logger使用的类名，此类必须实现org.apache.catalina.Logger 接口 prefix 指定log文件的前缀 suffix 指定log文件的后缀 timestamp 如果为true，则log文件名中要加入时间，如下例:localhost_log.001-10-04.txt Realm(表示存放用户名，密码及role的数据库) className 指定Realm使用的类名，此类必须实现org.apache.catalina.Realm接口 Valve(功能与Logger差不多，其prefix和suffix属性解释和Logger 中的一样) className 指定Valve使用的类名，如用org.apache.catalina.valves.AccessLogValve类可以记录应用程序的访问信息 directory 指定log文件存放的位置 pattern 有两个值，common方式记录远程主机名或ip地址，用户名，日期，第一行请求的字符串，HTTP响应代码，发送的字节数。combined方式比common方式记录的值更多 下载地址 在usr/local下新建目录Java [root@iz2ze0zcgmybh1wlebrk0mz local]# mkdir java 将下载好的jdk-7u71-linux-x64.rpm文件拷贝到 Java目录中 上传完后的文件如下，文件只有读写权限，没有执行权限 使用如下命令授权，如果文件已经有了执行权限，此步骤可省略 # chmod 755 jdk-7u71-linux-x64.rpm 2.安装JDK 执行如下命令安装jdk # rpm -ivh jdk-7u71-linux-x64.rpm 如果在安装时出现如下错误 warning:waiting for transaction lock on /var/lib/rpm/.rpm.lock 使用如下命令来进行安装 # sudo rpm -ivh jdk-7u71-linux-x64.rpm 如果仍然不可以，使用如下命令强制解锁后再次安装即可 # sudo rm /var/lib/rpm/.rpm.lock 3.配置环境变量 使用 vim 编辑器打开文件/etc/profile # vim /etc/profile 在文件尾部添加如下内容，保存退出 export JAVA_HOME=/usr/java/jdk1.7.0_71 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tool.jar 此时，我们刚刚配置的环境变量并没有起效，输入如下命令，使用环境变量立即生效 # source /etc/profile 输入如下命令验证环境变量是否生效 # echo $PATH 输入如下命令查看jdk版本 # java -version openjdk version \"1.8.0_181\" OpenJDK Runtime Environment (build 1.8.0_181-b13) OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode) yum安装JDK 1.检查系统原版并卸载 输入如下命令查看系统已安装的jdk # rpm -qa | grep java # rpm -qa | grep jdk 如果已经安装了jdk，使用如下命令卸载，yum会自动检测，卸载删除jdk的相关安装包 # yum -y remove java* # yum -y remove jdk* 2.jdk安装 查看java相关列表（jdk版本信息），笔者选择安装的是openjdk1.8 # yum list | grep jdk 3.使用如下命令安装jdk # yum -y install java-1.8.0-openjdk.x86_64 4. 等待安装完成，验证版本 # java -version openjdk version \"1.8.0_181\" OpenJDK Runtime Environment (build 1.8.0_181-b13) OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode) Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Tomcat/tomcat管理页面403解决方案.html":{"url":"source/Tomcat/tomcat管理页面403解决方案.html","title":"tomcat管理页面403解决方案","keywords":"","body":"tomcat管理页面403解决方案 安装tomcat之后，访问server status、manager app、host manager等页面，出现403 Access Denied错误 解决方法: 1.在conf/tomcat-users.xml文件里面，在前面添加如下代码： 然后重启tomcat，重新访问manager app页面，如果此时仍然出现403 Access Denied错误，那么就是访问的ip地受到了限制 我们打开webapps/manager/META-INF/目录下context.xml文件，不是conf/目录下的context.xml文件我们将里面的内容注释掉或者修改为: 成功进入如下界面 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Tomcat/检测tomcat是否存活并重启.html":{"url":"source/Tomcat/检测tomcat是否存活并重启.html","title":"检测tomcat是否存活并重启","keywords":"","body":"Linux下检测tomcat是否存活并重启 1. 编写tomcat检测存活重启脚本 只检测进程是否存在脚本 #!/bin/sh # function:自动监控tomcat进程，挂了就执行重启操作 #tomcat文件名称 TOMCAT_NAME=xxxxx #tomcat部署路径 TOMCAT_HOME=/home/local/tomcat # 日志输出 TOMCAT_MONITOR_LOG=/usr/local/shell/tomcatMonitor.log # 获取tomcat PPID TOMCAT_ID=$(ps -ef |grep tomcat |grep -w $TOMCAT_NAME|grep -v 'grep'|awk '{print $2}') # tomcat_startup START_TOMCAT=$TOMCAT_HOME/$TOMCAT_NAME/bin/startup.sh Monitor() { echo \"[info]开始监控tomcat...[$(date +'%F %H:%M:%S')]\" if [ $TOMCAT_ID ];then echo \"[info]$TOMCAT_NAME进程ID为:$TOMCAT_ID.\" echo \"$TOMCAT_NAME 状态正常... ending.\" else echo \"[error]进程不存在!$TOMCAT_NAME自动重启...\" echo \"[info]$START_TOMCAT,请稍候......\" $START_TOMCAT fi echo \"------------------------------\" } Monitor>>$TOMCAT_MONITOR_LOG 带url状态检测脚本 #!/bin/sh # function:自动监控tomcat进程，挂了就执行重启操作 #tomcat文件名称 TOMCAT_NAME=xxxxx #tomcat部署路径 TOMCAT_HOME=/home/local/tomcat #定义要监控的页面地址（写比较简单页面即可） WEB_URL=http://localhost:8080/xxxx/ # 日志输出 TOMCAT_MONITOR_LOG=/home/local/shell/tomcatMonitor.log # tomcat_startup START_TOMCAT=$TOMCAT_HOME/$TOMCAT_NAME/bin/startup.sh # 获取tomcat PPID TOMCAT_ID=$(ps -ef |grep tomcat |grep -w $TOMCAT_NAME|grep -v 'grep'|awk '{print $2}') # curl 日志-o /dev/null 屏蔽原有输出信息 CURL_MONITOR_LOG=/dev/null Monitor() { echo \"[info]开始监控$TOMCAT_NAME...[$(date +'%F %H:%M:%S')]\" #判断Tomcat进程是否存在 if [ $TOMCAT_ID ];then echo \"[info]$TOMCAT_NAME进程ID为:$TOMCAT_ID.继续检测......\" #检测是否启动成功（成功的话页面会返回状态\"200\"） TomcatServiceCode=$(curl -I -m 10 -o $CURL_MONITOR_LOG -s -w %{http_code} $WEB_URL) if [ $TomcatServiceCode -eq 200 ];then echo \"[info] curl $WEB_URL返回码为$TomcatServiceCode.\" echo \"$TOMCAT_NAME 状态正常... ending.\" else echo \"[error]$TOMCAT_NAME出错，请注意..状态码为$TomcatServiceCode，开始重启$TOMCAT_NAME...\" #杀掉原tomcat进程 kill -9 $TOMCAT_ID sleep 3 $START_TOMCAT fi else echo \"[error]进程不存在!$TOMCAT_NAME自动重启...\" echo \"[info]$START_TOMCAT,请稍候......\" $START_TOMCAT fi echo \"------------------------------\" } Monitor>>$TOMCAT_MONITOR_LOG 2. 对该脚本赋予执行权限 赋执行权限 [root@IDCWX05 shell]# chmod -R 777 tomcat-monitor.sh 3. 修改定时任务启动器 查看定时任务列表 [root@IDCWX05 shell]# crontab -l 05 09 * * * /usr/local/shell/time/build-dos2unix.sh */5 * * * * /usr/local/shell/tomcat-monitor.sh 编辑定时任务启动器 [root@IDCWX05 shell]# crontab -e 在打开的脚本页输入（每5分钟执行一次） */5 * * * * /usr/local/shell/tomcat-monitor.sh 正常保存退出即可生效 查看crontab状态 [root@IDCWX05 shell]# tail -f /var/log/cron Sep 10 20:19:57 IDCWX05 crontab[21591]: (root) LIST (root) Sep 10 20:20:01 IDCWX05 CROND[21599]: (root) CMD (/usr/local/shell/check_tomcat_live.sh) Sep 10 20:20:01 IDCWX05 CROND[21600]: (root) CMD (/usr/lib64/sa/sa1 1 1) Sep 10 20:21:01 IDCWX05 crontab[21616]: (root) BEGIN EDIT (root) Sep 10 20:21:02 IDCWX05 crontab[21616]: (root) END EDIT (root) Sep 10 20:25:01 IDCWX05 CROND[21627]: (root) CMD (/usr/local/shell/check_tomcat_live.sh) Sep 10 20:30:01 IDCWX05 CROND[21692]: (root) CMD (/usr/lib64/sa/sa1 1 1) Sep 10 20:30:01 IDCWX05 CROND[21693]: (root) CMD (/usr/local/shell/check_tomcat_live.sh) Sep 10 20:35:02 IDCWX05 CROND[21755]: (root) CMD (/usr/local/shell/check_tomcat_live.sh) Sep 10 20:35:32 IDCWX05 crontab[21766]: (root) LIST (root) ​ Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Tomcat/Tomcat部署错误集锦.html":{"url":"source/Tomcat/Tomcat部署错误集锦.html","title":"Tomcat部署错误集锦","keywords":"","body":"Tomcat部署错误集锦 Caused by: java.lang.IllegalArgumentException: More than one fragment with the name [spring_web] was found. This is not legal with relative ordering. See section 8.2.2 2c of the Servlet specification for details. Consider using absolute ordering. at org.apache.tomcat.util.descriptor.web.WebXml.orderWebFragments(WebXml.java:2200) at org.apache.tomcat.util.descriptor.web.WebXml.orderWebFragments(WebXml.java:2159) at org.apache.catalina.startup.ContextConfig.webConfig(ContextConfig.java:1124) at org.apache.catalina.startup.ContextConfig.configureStart(ContextConfig.java:769) at org.apache.catalina.startup.ContextConfig.lifecycleEvent(ContextConfig.java:299) at org.apache.catalina.util.LifecycleBase.fireLifecycleEvent(LifecycleBase.java:94) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5134) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) 解决方案:在web.xml加一个标签： /WEB-INF/view/index.jsp Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/持续集成/Jenkins搭建文档.html":{"url":"source/持续集成/Jenkins搭建文档.html","title":"Jenkins搭建文档","keywords":"","body":"Jenkins部署 准备Jenkins版本 （jenkins-2.32.3-1.1.noarch.rpm） 执行安装：rpm -ih jenkins-2.32.3-1.1.noarch.rpm 成功如下： 自动安装完成之后 /usr/lib/jenkins/jenkins.war WAR包 vim /etc/sysconfig/jenkins 配置文件 修改端口为9001 /var/lib/jenkins/ 默认的JENKINS_HOME目录 /var/log/jenkins/jenkins.log Jenkins日志文件 /var/lib/jenkins/secrets/initialAdminPassword 首次登陆密码 安装完成之后启动jenkins service jenkins start 跳过插件安装，待后续 设置用户名密码 admin df123456 131 admin Sz123456 安装插件 Deploy to Container Plugin （这个是支持将代码部署到tomcat容器的） GIT plugin Maven Integration plugin maven 项目 Git Parameter 参数化构建git项目，可选分支或tag构建（可用于定义备份tag，失败时回滚） 设置jdk、maven、git Global Tool Configuration Maven Configuration 默认 安装JDK 安装maven Git 安装 创建maven项目 Git 源码设置(chmod -R 777 /var/lib/jenkins) 设置git key免密登录 cp ~/.ssh/id_rsa /var/lib/jenkins/.ssh/ cp ~/.ssh/id_rsa.pub /var/lib/jenkins/.ssh/ //或者Cp ssh to /var/lib/jenkins/.ssh 设置权限 chown jenkins id_rsa.pub chown jenkins id_rsa chmod 400 id_rsa 如果构建报错权限问题 修改Jenkins用户权限为root vim /etc/passwd 修改后 jenkins:x:0:486:Jenkins Continuous Integration Server:/var/lib/jenkins:/bin/false 配置Tomcat user.xml文件 Jenkins执行远程Linux系统的shell命令 搜索并找到 SSH Slaves plugin 插件 删除 //服务 sudo apt-get remove jenkins //安装包，注意这里如果不是ubuntu那就yum sudo apt-get remove --auto-remove jenkins //配置和数据 sudo apt-get purge jenkins sudo apt-get purge --auto-remove jenkins Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/ELKF/ELKF日志管理平台搭建.html":{"url":"source/ELKF/ELKF日志管理平台搭建.html","title":"ELKF日志管理平台搭建","keywords":"","body":"ELKF日志管理平台搭建 一、整体架构简介 系统：Centos7 应用版本：Version:7.4.0 整体架构图 架构描述 Filebeat是一个轻量级日志传输Agent，通过Filebeat将项目日志传输至Logstash Logstash对日志进行过滤，将过滤完的日志传输到ElasticSearch中进行持久化 Kibana通过查询不同的ElasticSearch中不同的索引来获取到不能模块的日志信息并展示在监控平台上 一、安装Filebeat 1.下载Filebeat并上传至服务器/home/software目录 2.解压并重命名文件夹 [root@localhost /]# cd /home/software/ [root@localhost software]# tar -xvf filebeat-7.4.0-linux-x86_64.tar.gz [root@localhost software]# mv filebeat-7.4.0-linux-x86_64 filebeat 3. 修改配置文件 [root@localhost software]# vim filebeat/filebeat.yml filebeat.inputs: - type: log #更改为true以启用此输入配置 enabled: true paths: #修改系统日志所在位置 - /var/log/nginx/*.log # to add additional information to the crawled log files for filtering #配置索引名 fields: machine: master #应用名称 app: job-center multiline.pattern: ^\\[ multiline.negate: true multiline.match: after #此处filebeat.inputs可以配置多个 filebeat.config.modules: path: ${path.config}/modules.d/*.yml reload.enabled: false setup.template.settings: index.number_of_shards: 1 setup.kibana: #-------------------------- Elasticsearch output ------------------------------ #output.elasticsearch: # Array of hosts to connect to. # hosts: [\"localhost:9200\"] # Optional protocol and basic auth credentials. #protocol: \"https\" #username: \"elastic\" #password: \"changeme\" #----------------------------- Logstash output -------------------------------- #注释掉ElasticSearch output中内内容让它不直接输出到ElasticSearch #修改Logstash output中的output.logstash.hosts为你的Logstash所在机器 output.logstash: hosts: [\"localhost:5044\"] processors: - add_host_metadata: ~ - add_cloud_metadata: ~ 4.启动/停止应用 [root@localhost filebeat]# nohup ./filebeat -e -c filebeat.yml & #查看应用进程 [root@localhost filebeat]# ps -aux|grep filebeat #杀死进程 [root@localhost filebeat]# kill -9 进程号 二、安装Logstash 1.下载Logstash并上传至服务器/home/software目录 2.解压并重命名文件夹 [root@localhost /]# cd /home/software/ [root@localhost software]# tar -xvf logstash-7.4.0.tar.gz [root@localhost software]# mv logstash-7.4.0 logstash 3. 修改配置文件 [root@localhost software]# vim logstash/config/logstash-sample.conf # Sample Logstash configuration for creating a simple # Beats -> Logstash -> Elasticsearch pipeline. #beats.port配置接收Filebeat的数据的端口 input { beats { port => 5044 } } #output.elasticsearch配置在ElasticSearch中生成索引名的规则 output { elasticsearch { hosts => [\"http://localhost:9200\"] #在ElasticSearch中生成索引名的规则[logstash-job-center-2019.10.16] #这里通过生成不同的索引名来区分不同模块的日志文件 #Filebeat中配置fields.app index => \"logstash-%{[fields][app]}-%{+YYYY.MM.dd}\" #user => \"elastic\" #password => \"changeme\" } } 这里的 filebeat.inputs 是可以定义多个的，每个 filebeat.inputs 对应一个微服务模块日志配置，我们可以在fields下面自定义一些属性，然后在logstash的配置文件中获取到这个自定义属性，通过判断自定义属性来对每个模块做个性化索引配置。 4.启动/停止应用 [root@localhost logstash]# nohup ./bin/logstash -f ./config/logstash-sample.conf & #查看应用进程 [root@localhost logstash]# ps -aux|grep logstash #杀死进程 [root@localhost logstash]# kill -9 进程号 5.错误处理记录 Thread.exclusive is deprecated, use Thread::Mutex 解决：在 logstash.yml 文件中找到 Data path 的路径(默认在安装目录的data目录下） 查看是否存在 .lock 文件，如果存在把它删除 [root@ELK1 data]# ls -alh 总用量 20K drwxr-sr-x 4 tingshuo staff 4.0K 8月 19 11:42 . drwxr-sr-x 14 tingshuo staff 4.0K 8月 19 11:42 .. drwxr-sr-x 2 tingshuo staff 4.0K 8月 19 11:42 dead_letter_queue -rw-r--r-- 1 tingshuo staff 0 8月 19 11:42 .lock drwxr-sr-x 2 tingshuo staff 4.0K 8月 19 11:42 queue -rw-r--r-- 1 tingshuo staff 36 8月 19 11:42 uuid #删除带lock的文件 [root@ELK1 data]# rm .lock 三、安装ElasticSearch 1.下载ElasticSearch并上传至服务器/home/software目录 2.解压并重命名文件夹 [root@localhost /]# cd /home/software/ [root@localhost software]# tar -xvf elasticsearch-7.4.0-linux-x86_64.tar.gz [root@localhost software]# mv elasticsearch-7.4.0-linux-x86_64 elasticsearch 3. 修改配置文件 [elk@localhost elasticsearch]$ vim config/elasticsearch.yml #如果配置集群，不同ElasticSearch节点的node.name和http.port需要保持唯一 cluster.name: my-app-1 node.name: node-1 network.host: 0.0.0.0 http.port: 9200 #取消注释保留一个节点 cluster.initial_master_nodes: [\"node-1\"] 4.非root用户启动设置 我们需要创建一个elk用户和组，因为ElasticSearch不能以root身份运行，否则将会报错，执行以下命令 #添加elk用户组 [root@localhost elasticsearch]# groupadd elk #为用户组添加elk用户 [root@localhost elasticsearch]# useradd -g elk elk #赋予权限 [root@localhost elasticsearch]# chown -R elk:elk /usr/local/elasticsearch #启动es [elk@localhost elasticsearch]$ /home/software/elasticsearch/bin/elasticsearch -d #验证启动成功否、看到进程号就说明启动成功了 [elk@localhost elasticsearch]$ ps -aux|grep elasticsearch 5.启动/停止应用 #-d后台启动 [root@localhost elasticsearch]# /home/software/elasticsearch/bin/elasticsearch -d #查看应用进程 [root@localhost elasticsearch]# ps -aux|grep elasticsearch #杀死进程 [root@localhost elasticsearch]# kill -9 进程号 6.启动报错 [elk@localhost elasticsearch]$ ERROR: [3] bootstrap checks failed [1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535] [2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144] [3]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured 解决错误[1、2] 以root身份执行下面的脚本，执行后要重新登录普通账户启动ES #!/bin/bash echo \"* soft nofile 65536\">>/etc/security/limits.conf echo \"* hard nofile 65536\">>/etc/security/limits.conf echo \"* soft memlock unlimited\">>/etc/security/limits.conf echo \"* hard memlock unlimited\">>/etc/security/limits.conf echo \"vm.max_map_count = 262144\">>/etc/sysctl.conf sysctl -p ulimit -l unlimited 解决错误[3] #取消注释保留一个节点 cluster.initial_master_nodes: [\"node-1\"] 7.验证 [elk@localhost elasticsearch]$ curl http://localhost:9200/ { \"name\" : \"node-1\", \"cluster_name\" : \"my-app-1\", \"cluster_uuid\" : \"7i63wZl1SPCbsuQCJjrK5g\", \"version\" : { \"number\" : \"7.4.0\", \"build_flavor\" : \"default\", \"build_type\" : \"tar\", \"build_hash\" : \"22e1767283e61a198cb4db791ea66e3f11ab9910\", \"build_date\" : \"2019-09-27T08:36:48.569419Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.2.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } 四、安装Kibana 1.下载Kibana并上传至服务器/home/software目录 2.解压并重命名文件夹 [root@localhost /]# cd /home/software/ [root@localhost software]# tar -xvf kibana-7.4.0-linux-x86_64.tar.gz [root@localhost software]# mv kibana-7.4.0-linux-x86_64 kibana 3. 修改配置文件 server.port: 5601 #这里需要需改为实际IP，否则外部浏览器无法访问 server.host: \"192.xxx.xxx.xxx\" #汉化 i18n.locale: \"zh-CN\" 4.启动/停止应用 #后台启动 [elk@localhost kibana]$ nohup ./bin/kibana & #查看应用进程 [root@localhost kibana]# ps -aux|grep kibana #杀死进程 [root@localhost kibana]# kill -9 进程号 5.Kibana设置 访问浏览器：http://172.20.25.71:5601 管理-->索引模式-->创建索引模式 在Discover查看我们刚刚建立的索引规则匹配到的索引数据，如图所示 Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "},"source/Blog/使用gitbook搭建博客.html":{"url":"source/Blog/使用gitbook搭建博客.html","title":"使用gitbook搭建博客","keywords":"","body":"使用gitbook搭建博客 一、 安装node 检查node是否安装成功 $ node -v v10.16.0 二、安装gitbook 安装命令 npm install gitbook-cli -g 初始化项目(新建文件) $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished 启动服务，然后在浏览器地址栏中输入 http://localhost:4000 便可预览书籍 $ gitbook serve Starting server ... Serving book on http://localhost:4000 更多命令介绍 gitbook build #生成网页而不开启服务器 三、文件介绍 使用gitbook init后会自动生成两个文件README.md和SUMMARY.md README.md使用过git的都知道这个文件 SUMMARY.md就是自己要写文章章节目录 系统文件目录如下 发布后网页样式 四、通过配置文件来配置 在书籍下面都可以创建一个book.json { \"title\": \"标题\", \"author\": \"作者\", \"description\": \"简单描素\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.3\", \"styles\": { \"website\": \"./styles/website.css\" }, \"structure\": { \"readme\": \"README.md\" }, \"links\": { \"sidebar\": { \"我的博客\": \"https://blog.csdn.net/kuangshp128\" } }, \"plugins\": [ \"-sharing\", \"splitter\", \"expandable-chapters-small\", \"anchors\", \"github\", \"github-buttons\", \"donate\", \"sharing-plus\", \"anchor-navigation-ex\", \"favicon\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/kuangshp/\" }, \"github-buttons\": { \"buttons\": [{ \"user\": \"kuangshp\", \"repo\": \"mysql\", \"type\": \"star\", \"size\": \"small\", \"count\": true }] }, \"donate\": { \"alipay\": \"./source/images/donate.png\", \"title\": \"\", \"button\": \"赞赏\", \"alipayText\": \" \" }, \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": false, \"qzone\": false, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": false, \"whatsapp\": false, \"all\": [ \"google\", \"facebook\", \"weibo\", \"twitter\", \"qq\", \"qzone\", \"linkedin\", \"pocket\" ] }, \"anchor-navigation-ex\": { \"showLevel\": false }, \"favicon\": { \"shortcut\": \"./source/images/favicon.jpg\", \"bookmark\": \"./source/images/favicon.jpg\", \"appleTouch\": \"./source/images/apple-touch-icon.jpg\", \"appleTouchMore\": { \"120x120\": \"./source/images/apple-touch-icon.jpg\", \"180x180\": \"./source/images/apple-touch-icon.jpg\" } } } } 关于book.json字段的介绍 title: 书籍标题 author:书籍作者 description: 本书描述 language:语言(中文设置 \"zh-hans\" 即可) gitbook:gitbook的版本 styles:自定义样式 structure: readme文件的位置(指定 Readme、Summary、Glossary 和 Languages 对应的文件名) links:链接跳转{在左侧导航栏添加链接信息} plugins:插件 pluginsConfig:配置插件的属性 插件介绍 GitBook 有 插件官网，默认带有 5 个插件，highlight、search、sharing、font-settings、livereload，如果要去除自带的插件， 可以在插件名称前面加 -，比如： \"plugins\": [ \"-search\" ] 如果要配置使用的插件可以在 book.json 文件中加入即可，比如我们添加 plugin-github，我们在 book.json 中加入配置如下即可： { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/dolojia\" } } } 然后在终端输入 gitbook install ./ 即可。 如果要指定插件的版本可以使用 plugin@0.3.1，因为一些插件可能不会随着 GitBook 版本的升级而升级。 五、发布到github 在git上创建项目gitbook 将本地gitbook文件与GitHub上项目同步 gi$ git init $ git add . $ git commit -m \"first commit\" $ git remote add origin https://github.com/dolojia/gitboook.git $ git push -u origin master 在本地创建gh-pages分支 $ git checkout -b gh-pages $ git push $ git push --set-upstream origin gh-pages ​ 删除分支下文件，只保留_book/目录下文件的文件及.git文件夹，提交文件至gh-pages分支。 提交完成后到github仓库的设置中看一下，gh-pages服务是否自动开启，如果没有的话在Source中选择gh-pages branch，保存刷新，等待几分钟就好了 六、自动发发布脚本 以上操作过于繁杂，避免每次更新文件都要倒腾，写一个自动提交代码脚本自动同步代码至master跟gh-pages分支，创建文件push-gitbook.sh,内容如下： cd gitbook &&\\ git checkout master &&\\ gitbook init &&\\ gitbook build &&\\ git add . &&\\ git commit -m 'update gitbook' &&\\ git push origin master &&\\ git checkout gh-pages &&\\ rm -rf * &&\\ git checkout master -- _book &&\\ mv _book/* ./ &&\\ rm -rf _book &&\\ rm -rf publish.sh &&\\ git add . &&\\ git commit -m 'push-gitbook.sh gh-pages' &&\\ git push origin gh-pages &&\\ git checkout master 七、END 至此全部操作已经完成，接下来每次在本地更新书籍内容后，先生成静态页面，然后提交master分支，再提交、gh-pages分支就可以了。 最后通过下面地址访问线上内容： https://dolojia.github.io/gitbook Copyright © DoloJia 2019 all right reserved，powered by Gitbook修订时间： 2019-10-17 17:21:16 "}}